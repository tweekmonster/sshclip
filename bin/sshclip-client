#!/usr/bin/env bash
name="${BASH_SOURCE[0]##*/}"
readonly max_bytes=262144  # 256 KiB, which is already a lot for text
action=""
store=""
passthru=1
sshcmd=${SSHCLIP_SSHCMD:-"ssh sshclip-server"}
pidfile="$HOME/.cache/sshclip_monitor.pid"
crcfile="$HOME/.cache/sshclip.crc"


show_help() {
    cat <<EOF
sshclip-client [--impersonate [osx xclip xsel]] [-h]

Options:
    -h                  This thing here
    --impersonate       Create symlinks that impersonates another clipboard
                        program. Options are: osx, xclip, xsel, and sshclip.
    --no-passthru       Don't attempt to pass yoinks to the system's clipboard.
    --monitor           Monitor the system's clipboard to keep it in sync.

This script is a client for sshclip-server which acts as a personal clipboard
server that can be accessed over the network. The goal is to have a clipboard
program for Vim users that often have to work across multiple remote servers.

Recommended setup:

Generate a public/private key pair to authenticate with the server. Using
password authentication would be annoying if it worked in Vim.

    ssh-keygen -t rsa -b 2048 -N '' -f ~/.ssh/id_sshclip -C "sshclip@${HOST}"

Configure the server in ~/.ssh/config with multiplexing for faster
connections.

    Host sshclip-server
        Name example.com
        User sshclip
        IdentityFile ~/.ssh/id_sshclip
        ControlMaster auto
        ControlPersist 10m
        ControlPath ~/.ssh/control/sshclip-server

sshclip-server can be copied to your server and set as the shell for an
unprivileged, passwordless account.
EOF
    exit 1
}


bail() {
    >&2 echo "$1"
    exit 1
}


parse_args() {
    while [[ $# > 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                ;;
            -i*)
                action="put"
                ;;
            -o*)
                action="get"
                ;;
            -sel*)
                store="${2}"
                shift
                ;;
            -b|--clipboard)
                store="clipboard"
                ;;
            -p|--primary)
                store="primary"
                ;;
            -s|--secondary)
                store="secondary"
                ;;
            --no-passthru)
                passthru=0
                ;;
        esac
        shift
    done
}


resolve_links() {
    file="$1"
    cd $(dirname "$file")
    file=$(basename "$file")
    i=0
    while [ -L "$file" ]; do
        file=$(readlink "$file")
        cd "$(dirname "$file")"
        file=$(basename "$file")

    done
    echo "$(pwd -P)/${file}"
}


find_system_clipboard() {
    # First argument is a boolean flag indicating we want the bin that
    # retrieves the clipboard.
    #
    # This function is due to my ignorance of other system clipboards.
    # This should be replaced by hard coded paths. I can't think of any reason
    # the system clipboard programs would be in different locations.
    paste="$1"
    self=$(resolve_links "${BASH_SOURCE[0]}")
    found=""
    clipboards=("pbcopy xclip xsel")
    for prog in $clipboards; do
        for item in $(which -a "$prog"); do
            item=$(resolve_links "$item")
            if [[ "$item" != "$self" ]]; then
                found=$item
                break 2
            fi
        done
    done

    if [[ -n "$found" ]]; then
        found_name=$(basename "$found")
        found_args="-i"

        case $found_name in
            pbcopy)
                found_args=""
                [[ -n "$paste" ]] && found="${found/%pbcopy/pbpaste}"
                ;;
            xclip|xsel)
                [[ -n "$paste" ]] && found_args="-o"
                if [[ "$found_name" == "xsel" ]]; then
                    case $store in
                        clipboard)
                            found_args="$found_args -b"
                            ;;
                        primary)
                            found_args="$found_args -p"
                            ;;
                        secondary)
                            found_args="$found_args -s"
                            ;;
                    esac
                fi
                ;;
        esac

        echo "$found $found_args"
    fi
}


do_clipboard() {
    if [[ -z "$action" ]]; then
        show_help
        exit 1
    fi


    case $store in
        clipboard|primary|secondary)
            ;;
        *)
            bail "Incorrect store, use: clipboard, primary, or secondary"
            ;;
    esac


    # Using base64 to ensure data isn't mangled in transport
    # sshclip-server strips what it recieves of non-printable characters
    # If ~/.sshclip_key exists and is not world readable, use aes-256 encryption
    keyfile="${HOME}/.sshclip_key"
    encoder="base64"
    decdoer="base64 --decode"

    if [[ -f "$keyfile" ]]; then
        [[ -n $(find "$keyfile" -perm +0006) ]] && bail "$keyfile is world readable"
        encoder="openssl aes-256-cbc -a -salt -pass file:$keyfile"
        decoder="openssl aes-256-cbc -a -d -salt -pass file:$keyfile"
    fi

    case $action in
        put)
            [[ $passthru -eq 1 ]] && passthru_cmd=$(find_system_clipboard)
            if [[ -n "$passthru_cmd" && "$store" == "clipboard" ]]; then
                logger "Passthru to: ${passthru_cmd}"
                tee >(cksum > "$crcfile") >($passthru_cmd) | head -c $max_bytes | $encoder | $sshcmd "put $store"
            else
                head -c $max_bytes | $encoder | $sshcmd "put $store"
            fi
            ;;
        get)
            $sshcmd "get ${store}" | $decoder
            ;;
        *)
            bail "Uknown action: ${action}"
            ;;
    esac
}


monitor() {
    monitor_run=1

    if [[ -e "$pidfile" ]]; then
        kill -s 0 `cat $pidfile` && bail "Another instance is running"
    else
        mkdir -p "${pidfile%/*}"
    fi

    echo -n $$ > "$pidfile"
    trap "rm -f '${pidfile}'" EXIT

    store="clipboard"
    sys_clipboard_get=$(find_system_clipboard 1)

    if [[ -z "$sys_clipboard_get" ]]; then
        bail "System clipboard not found"
    fi

    while [[ monitor_run -eq 1 ]]; do
        # Not sure if the following will cause problems for other systems.
        # Conversion of \r to \n is for programs that still haven't updated their
        # code to recognize that \r is not the line ending for OS X.
        # *cough*synergy*cough*
        contents=$($sys_clipboard_get | tr "\r" "\n")
        crc=$(echo -n "$contents" | cksum)
        if [[ -f "$crcfile" ]]; then
            outside_crc=$(cat "$crcfile")
            rm "$crcfile"
            [[ "$crc" == "$outside_crc" ]] && sys_clipboard_crc="$outside_crc"
        fi

        if [[ "$crc" != "$sys_clipboard_crc" ]]; then
            sys_clipboard_crc="$crc"
            action="put"
            echo "$contents" | do_clipboard 2> /dev/null
        fi
        contents=""
        sleep 1
    done
}


impersonate() {
    dir="${HOME}/bin"
    real=$(resolve_links "${BASH_SOURCE[0]}")
    links=()

    case $1 in
        osx)
            links=(
                "${dir}/pbcopy"
                "${dir}/pbpaste"
            )
            ;;
        sshclip)
            links=(
                "${dir}/sshclip-get"
                "${dir}/sshclip-put"
            )
            ;;
        xclip)
            links=(
                "${dir}/xclip"
            )
            ;;
        xsel)
            links=(
                "${dir}/xsel"
            )
            ;;
        *)
            bail "Impersonate options: osx, xclip, or xsel"
            ;;
    esac

    for link in  ${links[@]}; do
        echo "Linking $link"
        ln -s "$real" "$link"
    done

    echo "Created symlinks for $1"
}


if [[ $1 == "--impersonate" ]]; then
    if [[ $name != "sshclip-client" ]]; then
        bail "Use sshclip-client to impersonate another program"
    fi

    impersonate $2
    exit 0
elif [[ $1 == "--monitor" ]]; then
    monitor
    exit 0
fi

parse_args $@


case $name in
    pbcopy)
        action="put"
        store="clipboard"
        ;;
    pbpaste)
        action="get"
        store="clipboard"
        ;;
    sshclip-get)
        action="get"
        [[ -z "$store" ]] && store="clipboard"
        ;;
    sshclip-put)
        action="put"
        [[ -z "$store" ]] && store="clipboard"
        ;;
    xclip|xsel|sshclip-client)
        ;;
    *)
        bail "Not sure how to read arguments"
        ;;
esac


do_clipboard

# vim: set ts=4 sw=4 tw=0 et :
